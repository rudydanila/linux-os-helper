
### Модуль ps.

При загрузке операционной системы на базе Linux сначала запускается ядро. Ядро, в свою очередь, отвечает за запуск первого процесса, которым в современных дистрибутивах является процесс systemd. Этот процесс отвечает за все остальные процессы. При запуске процесса systemd запускает его как дочерний процесс. Запущенный дочерний процесс, в свою очередь, может запускать другие процессы. В итоге образуется дерево процессов.

Для просмотра дерева процессов можно использовать команду pstree:

```
eugene@Eugene:~$ pstree
systemd─┬─ModemManager───3*[{ModemManager}]
        ├─NetworkManager───3*[{NetworkManager}]
        ├─accounts-daemon───3*[{accounts-daemon}]
        ├─apache2───5*[apache2]
        ├─avahi-daemon───avahi-daemon
        ├─bluetoothd
        ├─boltd───3*[{boltd}]
        ├─colord───3*[{colord}]
        ├─cron
        ├─cups-browsed───3*[{cups-browsed}]
        ├─cupsd───dbus
        ├─dbus-daemon
        ├─fwupd───5*[{fwupd}]
        ├─gdm3─┬─gdm-session-wor─┬─gdm-wayland-ses─┬─gnome-session-b───3*[{gnom+
        │      │                 │                 └─3*[{gdm-wayland-ses}]
        │      │                 └─3*[{gdm-session-wor}]
        │      └─3*[{gdm3}]
        ├─irqbalance───{irqbalance}
        ├─2*[kerneloops]
```

Для мониторинга процессов в Linux предназначена команда ps. Эта команда принимает много опций, но обычно используются наборы опций `aux` и `-ef`. Например, для просмотра состояния всех процессов применяется команда ps aux:

```
eugene@Eugene:~$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0 169800 12476 ?        Ss   07:30   0:02 /sbin/init sp
root           2  0.0  0.0      0     0 ?        S    07:30   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   07:30   0:00 [rcu_gp]
root           4  0.0  0.0      0     0 ?        I<   07:30   0:00 [rcu_par_gp]
root           5  0.0  0.0      0     0 ?        I<   07:30   0:00 [slub_flushwq
root           6  0.0  0.0      0     0 ?        I<   07:30   0:00 [netns]
......................................
root       19078  0.0  0.0      0     0 ?        I    14:09   0:00 [kworker/6:0]
eugene     19108  0.0  0.0 1186478064 65184 ?    Sl   14:10   0:00 /opt/google/c
root       19170  0.0  0.0      0     0 ?        I    14:14   0:00 [kworker/u48:
eugene     19276  100  0.0  14144  4992 pts/0    R+   14:24   0:00 ps aux
```

Формально `aux` состоит из трех опций: опция a обеспечивает отображение всех процессов, опция u предоставляет расширенную информацию об использовании, а опция x показывает, с какого TTY и каким пользователем запускается процесс. Вкратце разберем выводимые столбцы:

- USER: имя пользователя, запустившего процесс.
    
- PID: PID - идентификатор процесса. Команда `ps aux` сортирует процессы по их PID.
    
- %CPU: процент процессорного времени, использованного процессом с момента запуска.
    
- %MEM: процент памяти, используемый процессом в данный момент.
    
- VSZ: общий объем памяти, затребованный этим процессом.
    
- RSS: общий объем памяти, используемой процессом в данный момент.
    
- TTY: терминал (TTY), с которого был запущен процесс. Знак вопроса указывает на процесс демона, который не связан ни с каким TTY.
    
- STAT: текущее состояние процесса.
    
- START: время запуска процесса.
    
- TIME: общее количество системного времени, использованное этим процессом с момента его запуска.
    
- COMMAND: команда, которая использовалась для запуска этого процесса. Если имя этой команды заключено в квадратные скобки, процесс запускается не командой в командной строке, а является потоком ядра.
    

Аналогичный вывод можно получить, использовав другую комбинацию опций - `-ef`

```
eugene@Eugene:~$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 09:26 ?        00:00:00 /sbin/init splash
root           2       0  0 09:26 ?        00:00:00 [kthreadd]
root           3       2  0 09:26 ?        00:00:00 [rcu_gp]
root           4       2  0 09:26 ?        00:00:00 [rcu_par_gp]
root           5       2  0 09:26 ?        00:00:00 [slub_flushwq]
root           6       2  0 09:26 ?        00:00:00 [netns]
root           7       2  0 09:26 ?        00:00:00 [kworker/0:0-rcu_par_gp]
root           8       2  0 09:26 ?        00:00:00 [kworker/0:0H-events_highpri
root           9       2  0 09:26 ?        00:00:00 [kworker/0:1-cgroup_destroy]
root          10       2  0 09:26 ?        00:00:00 [kworker/u48:0-flush-259:0]
root          11       2  0 09:26 ?        00:00:00 [mm_percpu_wq]
..................................................................
eugene      4096    3806  0 09:29 ?        00:00:00 /snap/code/155/usr/share/cod
eugene      4117    3806  3 09:29 ?        00:00:01 /snap/code/155/usr/share/cod
eugene      4153    4117  2 09:29 ?        00:00:01 /snap/code/155/usr/share/cod
eugene      4248    3601 50 09:30 pts/0    00:00:00 ps -ef
eugene@Eugene:~$ 
```

Вначале идут столбцы пользователя (UID), который запустил процесс, и идентификатора процесса (PID). В отличие от предыдущий сводки команда также выводит столбец PPID, который хранит идентификатор родительского процесса. Затем идет столбец C, который показывает использование процессора этим процессом, что аналогично столбцу `%CPU` в сводке команды `ps aux`.

Сочетания эту команду с командами обработки текста, мы можем сделать некое подобие фильтрации. Например, получим все процессы, у которых команда содержит "gnome":

```
eugene@Eugene:~$ ps aux | grep gnome
eugene      2520  0.0  0.0 298564 16320 tty2     Sl+  09:27   0:00 /usr/libexec/gnome-session-binary --session=ubuntu
eugene      2599  0.0  0.0  91492  5376 ?        Ssl  09:27   0:00 /usr/libexec/gnome-session-ctl --monitor
eugene      2645  5.7  0.5 6473112 337724 ?      Ssl  09:27   6:17 /usr/bin/gnome-shell
eugene      2800  0.0  0.0 235984  7296 ?        Sl   09:27   0:00 /usr/libexec/at-spi2-registryd --use-gnome-session
eugene      2819  0.0  0.0 655292 16320 ?        Sl   09:27   0:00 /usr/libexec/gnome-shell-calendar-server
eugene      3210  0.0  0.0 897828 40236 ?        Ssl  09:27   0:00 /usr/libexec/xdg-desktop-portal-gnome
eugene      3581  0.4  0.0 706412 59960 ?        Ssl  09:28   0:31 /usr/libexec/gnome-terminal-server
eugene     10800  0.0  0.0   9120  2112 pts/0    S+   11:16   0:00 grep --color=auto gnome
eugene@Eugene:~$ 
```

Аналогично, например, найдем все процессы, связанные с браузером Google Chrome:

```
ps aux | grep chrome
```

Завершение процесса

Завершение процессов представляет одну из наиболее распространенных задач при работе процессами. Для завершения процесса Linux предоставляет ряд команд: kill, pkill и killall. При использовании одной из этих команд можно отправить процессу определенный сигнал. Сигнал представляет команду процессу. Всего доступно 32 сигнала, но из них только четыре являются общими:

|   |   |   |
|---|---|---|
|Сигнал|Значение|Описание|
|SIGHUP|1|Используется при изменении файла конфигурации. Позволяет процессу применить новые настройки конфигурации|
|SIGKILL|9|Принудиьтельно завершает процесс. Так как при использовании этого сигнала есть риск потери несохраненных данные из открытых файлов, то данный сигнал используется только в том случае, если процесс не останавливается после отправки ему сигнала 15.|
|SIGTERM|15|Запрашивает завершение процесса. Процесс может игнорировать это.|
|SIGUSR1|30|Посылает определенный пользователем сигнал|

### kill

Команда kill обеспечивает наиболее распространенный способ отправки сигналов процессам, и вы обнаружите, что ее довольно легко использовать. Эта команда принимает два аргумента: номером или именем сигнала и PID процесса, который надо завершить:

kill [-s sigspec | -n signum] pid

Опция `-s` задает имя сигнала, а опция `-n` - номер сигнала. Если вы не указаны имя/номер сигнала, kill по умолчанию отправит сигнал 15, запрашивая завершение процесса.

Поскольку команда принимает идентификатор завершаемого процесса, то нам надо сначала получить этот идентификатор. Например, у нас запущен браузер Chrome, и мы хотим его завершить. Сначала получим идентификатор процесса:

```
eugene@Eugene:~$ pgrep -l chrome
3822 chrome_crashpad
10848 chrome
10857 chrome_crashpad
10859 chrome_crashpad
10865 chrome
10866 chrome
10868 chrome
10892 chrome
10893 chrome
10904 chrome
11333 chrome
11346 chrome
```

Обычно запущенное окно браузера представляет первый в списке процессов с именем "chrome". В моем случае - это 10848. Теперь завершим его:

```
eugene@Eugene:~$ kill 10848
```

Также можно завершить сразу несколько процессов, указав их идентификаторы через пробел:

```
kill 10848 3822
```

### killall

Команда killall позволяет более точно указать процессы, которые надо завершить. Среди ее опций можно выделить следующие:

- `-I`: игнорирует регистр имени процессов
    
- `-r`: позволяет указать регулярное выражение, которому должны соответствовать процесс.
    
- `-u`: позволяет указать пользователя, процессы которого будут завершены.
    

Например, завершим работу браузера google chrome:

killall -r chrome

Причем в данном случае "chrome" - это регулярное выражение. Например, завершим процессы, в имени которых есть "chrome_":

```
eugene@Eugene:~$ pgrep -l chrome
11808 chrome
11817 chrome_crashpad
11819 chrome_crashpad
11825 chrome
11826 chrome
11828 chrome
11853 chrome
11855 chrome
11867 chrome
eugene@Eugene:~$ killall -r chrome_
eugene@Eugene:~$ pgrep -l chrome
11808 chrome
11825 chrome
11826 chrome
11828 chrome
11853 chrome
11855 chrome
11867 chrome
eugene@Eugene:~$ 
```

### pkill

Команда pkill завершает процесс на основании его имени или атрибутов.

Приведу основные опции, которые может принимать команда:

- `-i, --ignore-case`: при соответствии шаблону не учитывается регистр
    
- `-n, --newest`: выбирает наиболее новые процессы
    
- `-o, --oldest`: выбирает наиболее старые процессы
    
- `-O, --older <seconds>`: выбирает процессы, которые запущены как минимум seconds секунд назад
    
- `-P, --parent <PPID,...>`: выбирает только дочерние процессы определенного родительского процесса с идентификаторомPPID
    
- `-u, --euid <ID,...>`: выбирает процессы по определенному пользователю
    
- `-x, --exact`: устанавливает точное соответствие имени команды
    

Например, завершим все процессы бразера chrome:

```
pkill chrome
```